<!DOCTYPE html>
<html>
  <meta charset="UTF-8" />
  <title>Manas' Writing Board</title>
  <head>
    <!-- Link Bootstrap CSS -->
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
    />
    <!-- Link Bootstrap JS and JQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"></script>
    <link rel="shortcut icon" href="../img/icon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="../css/style.css" />
  </head>
  <body>
    <div class="container" style="margin-top: 2%;">
      <h3>SOLID Design Principles</h3>
      <p>Sep 28, 2020</p>
        <img src="../img/solid.jpg" width= "100%" height="420" className="solid-article-display">
        <p style="margin-top: 3%;">
        SOLID design principles is very much preferred in object-oriented
        software development. Adopting these practices can also contribute to
        avoiding code smells, refactoring code, and Agile or Adaptive software development. Itâ€™s a
        mnemonic acronym for the following five design principles:<br />
      </p>

      <div style="padding-left: 3%;">
        <ul>
          <li><b>S</b>ingle Responsibility Principle</li>
          <li><b>O</b>pen/Closed Principle</li>
          <li><b>L</b>iskov Substitution Principle</li>
          <li><b>I</b>nterface Segregation Principle</li>
          <li><b>D</b>ependency Inversion</li>
        </ul>
      </div>
      <br />
      <b>Single Responsibility Principle:</b>&nbsp; A class should have one, and only
      one reason to change. <br />
      <p>
          <pre>
              <code>
                public class Employee { 
                    private String name; 
                    private String designation; 
                    private double salary; 
                    <i>// constructor, getters and setters </i>
                    <i>// methods that directly relate to the employee properties </i>
            
                    public String convertSalaryToString(double salary){ 
                    return String.valueOf(salary); }
                }
              </code>
          </pre>

        Now, the Employee class works well, and we can store as many employees
        as we like in our application.
        Let's throw caution to the wind and add a print method:
        <pre>
        <code>
                public class Employee { 
                    //<i>...</i> 
                    void printNameToConsole(){ 
                        // <i>our code for printing the name of employee </i>
                    }
                }
            </code>
        </pre>

        <p>This code does, however, violate the single responsibility principle we
        outlined earlier. To fix our mess, we should implement a separate class that is concerned only with
        printing the name of the employee.</p>
    
        <p><b>Open/Closed Principle:</b> Objects or entities should be open for
        extension but closed for modification. In doing so, we stop ourselves from modifying existing code and causing
        potential new bugs in an otherwise running application. Of course, the one exception to the rule is when fixing bugs in existing
        code.</p>


        <p><b>Liskov Substitution:</b> If class A is a subtype of class B, then we
        should be able to replace B with A without disrupting the behavior of our program.</p>

        <pre>
            <code>
                public interface Car { 
                    void turnOnEngine(); 
                    void accelerate(); 
                }

                public class MotorCar implements Car { 
                    private Engine engine; 
                    //<i>Constructors, getters + setters </i>

                    public void turnOnEngine() { 
                        //<i>turn on the engine! </i>
                        engine.on(); 
                        } public void accelerate() { 
                        //<i>move forward!</i>
                        engine.powerOn(1000); 
                    }
                }
            </code>
        </pre>
        <p>
            This means that every subclass or derived class should be substitutable
            for their base or parent class.
        </p>

        <p>
            <b>Interface Segregation Principle:</b> Larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about
            the methods that are of interest to them. </p>

            <p>
                <b>Dependency Inversion:</b> The principle of Dependency Inversion refers to the decoupling of software modules. This way, instead of high-level modules depending on low-level modules,
                both will depend on abstractions. 
            </p>
            <pre>
                <code>
                    public class Windows98Machine {
                    
                    private final StandardKeyboard keyboard; 
                    private final Monitor monitor;
            
                    public Windows98Machine() { 
                        monitor = new Monitor(); 
                        keyboard = new StandardKeyboard(); 
                    }
                    }

                    // <i>Here code is tightly coupled. The better approach will be:</i>

                    public class Windows98Machine{
            
                        private final Keyboard keyboard; 
                        private final Monitor monitor;
                        
                        public Windows98Machine(Keyboard keyboard, Monitor monitor) { 
                            this.keyboard = keyboard; 
                            this.monitor = monitor;
                        }
                    }
                </code>
            </pre>       
            Here, we're using the dependency injection pattern here to facilitate
            adding the Keyboard dependency into the Windows98Machine class.
        
      </p>
    </div>
  </body>
</html>
